"""Fixtures for e2e import tests."""

import tempfile
import uuid
from collections.abc import AsyncIterator, Callable
from contextlib import asynccontextmanager
from pathlib import Path
from typing import TYPE_CHECKING

import httpx
import pytest
from aiohttp import web
from destiny_sdk.enhancements import EnhancementFileInput
from destiny_sdk.references import ReferenceFileInput
from elasticsearch import AsyncElasticsearch

from app.domain.robots.models.models import Robot
from tests.e2e.conftest import host_name
from tests.e2e.factories import ReferenceFactory
from tests.e2e.utils import refresh_reference_index

if TYPE_CHECKING:
    from app.domain.references.models.models import Reference


@pytest.fixture
def generate_sdk_reference_file_inputs() -> Callable[[int], list[ReferenceFileInput]]:
    """Get a random ReferenceFileInput."""

    def _make(n: int) -> list[ReferenceFileInput]:
        assert n > 0, "n must be greater than 0"
        references: list[Reference] = ReferenceFactory.build_batch(n)
        return [
            ReferenceFileInput(
                visibility=r.visibility,
                enhancements=[
                    EnhancementFileInput(**e.model_dump()) for e in r.enhancements or []
                ],
                identifiers=[i.identifier for i in r.identifiers or []],
            )
            for r in references
        ]

    return _make


@pytest.fixture
def get_import_file_signed_url():
    """
    Serve ReferenceFileInput as a JSONL file via a tiny async HTTP server.

    Can't be done via minio as the hostnames differ between the test env and the
    application, and the test env's host is used to sign the URL. (Python client won't)
    allow overriding the hostname in the signed URL.) I'm sure there's a workaround but
    this is fine for now. I did try execcing into containers but that was worse.

    Only a problem for importing, everything else has signed urls generated by the app.
    """

    @asynccontextmanager
    async def _upload(
        sdk_reference_file_input: list[ReferenceFileInput],
    ) -> AsyncIterator[str]:
        """Upload and yield a signed URL."""
        assert len(sdk_reference_file_input) > 0, "Must provide at least one reference"
        content = "\n".join(r.to_jsonl() for r in sdk_reference_file_input).encode(
            "utf-8"
        )
        name = f"{uuid.uuid4()}.jsonl"
        tempdir = tempfile.TemporaryDirectory()
        filepath = Path(tempdir.name) / name
        with Path.open(filepath, "wb") as f:
            """Write the file."""
            f.write(content)

        async def handle(_request: web.Request) -> web.FileResponse:
            """Serve the file."""
            return web.FileResponse(filepath)

        app = web.Application()
        app.router.add_get(f"/{name}", handle)
        runner = web.AppRunner(app)

        # Remove threading and manual event loop management.
        await runner.setup()
        site = web.TCPSite(runner, "0.0.0.0", 0)  # noqa: S104
        await site.start()
        port = site._server.sockets[0].getsockname()[1]  # type: ignore[union-attr, attr-defined]  # noqa: SLF001
        url = f"http://{host_name}:{port}/{name}"

        try:
            yield url
        finally:
            await runner.cleanup()
            tempdir.cleanup()

    return _upload


@pytest.fixture
async def robot_automation_on_all_imports(
    destiny_client_v1: httpx.AsyncClient, es_client: AsyncElasticsearch, robot: Robot
) -> uuid.UUID:
    """Create a robot automation that runs on all imports."""
    response = await destiny_client_v1.post(
        "/enhancement-requests/automations/",
        json={
            "robot_id": str(robot.id),
            "query": {"match_all": {}},
        },
    )
    assert response.status_code == 201
    await refresh_reference_index(es_client)
    return robot.id
